[
  {
    "name": "Candy",
    "version": 1,
    "files": [
      {
        "name": "Candy.scala",
        "contents": "// Smart Contract for a simple Candy Shop\n\nimport stainless.smartcontracts._\nimport stainless.lang.StaticChecks._\nimport stainless.annotation._\n\ntrait Candy extends Contract {\n  var initialCandies: Uint256    // Initial number of candies in the shop\n  var remainingCandies: Uint256  // Current number of candies in the shop\n  var eatenCandies: Uint256      // Number of candies already eaten\n  \n  // Initialze the shop with the given number of candies\n  @solidityPublic\n  final def constructor(_candies: Uint256) = {\n    initialCandies = _candies\n    remainingCandies = _candies\n    eatenCandies = Uint256.ZERO\n  }\n  \n  // Eat the given number of candies and remove them from the shop\n  @solidityPublic\n  final def eatCandy(candies: Uint256) = {\n    dynRequire(candies <= remainingCandies)\n    \n    remainingCandies -= candies\n    eatenCandies += candies\n  }\n  \n  // Return the current number of candies in the shop\n  @solidityPublic @solidityView\n  final def getRemainingCandies() = remainingCandies\n  \n  // Conditions that should always be true\n  @ghost @inline\n  final def invariant(): Boolean = {\n    eatenCandies <= initialCandies &&\n    remainingCandies <= initialCandies &&\n    initialCandies - eatenCandies == remainingCandies\n  }\n}\n"
      }
    ]
  },
  {
    "name": "DAO bad",
    "version": 1,
    "files": [
      {
        "name": "DAO_bad.scala",
        "contents": "// Illustration of a vulnerability in the DAO\n\nimport stainless.smartcontracts._\nimport stainless.lang._\nimport stainless.collection._\nimport stainless.annotation._\n\nimport Environment._\n\n// Smart Contract modelling the DAO\ntrait DAO extends Contract {\n  var totalCoins: Uint256       // Total number of coins in the fund\n  var userBalance: Uint256      // Current balance belonging to the user\n  var contractBalance: Uint256  // Current balance left in the contract\n  \n  var user: Malicious\n \n  // Condition that should always be true\n  @ghost @inline\n  final def invariant() = userBalance + contractBalance == totalCoins\n \n  // Initialize the fund with the total number of coins, the user balance, and the user identity\n  @solidityPublic\n  final def constructor(_totalCoins: Uint256, _userBalance: Uint256, _user: Malicious) = {\n    dynRequire(_userBalance <= _totalCoins)\n\n    totalCoins = _totalCoins\n    userBalance = _userBalance\n    user = _user\n\n    contractBalance = _totalCoins - _userBalance\n  }\n \n  // Return the total number of coins in the fund\n  @solidityPublic @solidityView\n  final def getTotalCoins() = totalCoins\n \n  // Return the current balance in the contract\n  @solidityPublic @solidityView\n  final def getContractBalance() = contractBalance\n \n  // Return the current balance belonging to the user\n  @solidityPublic @solidityView\n  final def getUserBalance() = userBalance\n \n  // Called by the user to withdraw his balance from the fund\n  @solidityPublic\n  final def withdrawBalance() = {\n    val amount = userBalance\n    \n    user.transfer(amount)\n    \n    totalCoins = totalCoins - amount\n    userBalance = Uint256.ZERO\n  }\n}\n\n// Smart Contract modelling a (malicious) investor\ntrait Malicious extends Contract {\n  var balance: Uint256  // Balance in the user's hands\n  var counter: Uint256  // Counter used to try multiple withdrawals\n \n  // Initialize the user\n  @solidityPublic\n  final def constructor() = {\n    balance = Uint256.ZERO\n    counter = Uint256.ZERO\n  }\n \n  // Return the balance in the user's hande\n  @solidityPublic @solidityView\n  final def getBalance() = balance\n \n  // Called by the DAO to transfer money from the fund to the user\n  @solidityPublic\n  final def transfer(amount: Uint256): Unit = {\n    balance += amount\n    \n    counter += Uint256(\"1\")\n    if (counter < Uint256(\"3\")) {\n      unsafeCast[DAO](Msg.sender).withdrawBalance()\n    }\n  }\n}\n"
      }
    ]
  },
  {
    "name": "DAO good",
    "version": 1,
    "files": [
      {
        "name": "DAO_good.scala",
        "contents": "// Illustration of a vulnerability in the DAO\n\nimport stainless.smartcontracts._\nimport stainless.lang._\nimport stainless.collection._\nimport stainless.annotation._\n\nimport Environment._\n\n// Smart Contract modelling the DAO\ntrait DAO extends Contract {\n  var totalCoins: Uint256       // Total number of coins in the fund\n  var userBalance: Uint256      // Current balance belonging to the user\n  var contractBalance: Uint256  // Current balance left in the contract\n  \n  var user: Malicious\n  \n  // Condition that should always be true\n  @ghost @inline\n  final def invariant() = userBalance + contractBalance == totalCoins\n  \n  // Initialize the fund with the total number of coins, the user balance, and the user identity\n  @solidityPublic\n  final def constructor(_totalCoins: Uint256, _userBalance: Uint256, _user: Malicious) = {\n    dynRequire(_userBalance <= _totalCoins)\n\n    totalCoins = _totalCoins\n    userBalance = _userBalance\n    user = _user\n\n    contractBalance = _totalCoins - _userBalance\n  }\n  \n  // Return the total number of coins in the fund\n  @solidityPublic @solidityView\n  final def getTotalCoins() = totalCoins\n  \n  // Return the current balance in the contract\n  @solidityPublic @solidityView\n  final def getContractBalance() = contractBalance\n  \n  // Return the current balance belonging to the user\n  @solidityPublic @solidityView\n  final def getUserBalance() = userBalance\n  \n  // Called by the user to withdraw his balance from the fund\n  @solidityPublic\n  final def withdrawBalance() = {\n    val amount = userBalance\n    \n    totalCoins = totalCoins - amount\n    userBalance = Uint256.ZERO\n    \n    user.transfer(amount)\n  }\n}\n\n// Smart Contract modelling a (malicious) investor\ntrait Malicious extends Contract {\n  var balance: Uint256  // Balance in the user's hands\n  var counter: Uint256  // Counter used to try multiple withdrawals\n  \n  // Initialize the user\n  @solidityPublic\n  final def constructor() = {\n    balance = Uint256.ZERO\n    counter = Uint256.ZERO\n  }\n  \n  // Return the balance in the user's hande\n  @solidityPublic @solidityView\n  final def getBalance() = balance\n  \n  // Called by the DAO to transfer money from the fund to the user\n  @solidityPublic\n  final def transfer(amount: Uint256): Unit = {\n    balance += amount\n    \n    counter += Uint256(\"1\")\n    if (counter < Uint256(\"3\")) {\n      unsafeCast[DAO](Msg.sender).withdrawBalance()\n    }\n  }\n}\n"
      }
    ]
  }
]
